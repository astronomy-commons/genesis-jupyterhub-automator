#!/bin/bash

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
cd "$DIR"

TEMPLATES=($(ls templates/config/config.sh.* | grep -v '.*~'))
CONFIG=etc/Makefile.config

#############################################################################3
# Functions
#############################################################################3

# Extract command-line options
option_to_varname()
{
	# takes an option such as --with-foo as an argument
	# and returns the corresponding variable name (FOO)
	key="${1%=*}"
	key="${key#--}"
	key="${key#with-}"
	key="${key//-/_}"
	echo "$key" | awk '{print toupper($0)}'
}

# Convert a variable name to equivalent option
varname_to_option()
{
	opt="${1//_/-}"
	opt=$(echo "$opt" | awk '{print tolower($0)}')
	echo "--$opt"
}


# Output an error message
errmsg()
{
	echo "$@" 1>&2
}

# Check if a docker image exists in the (public) repository
docker_tag_exists()
{
    curl --silent -f -lSL https://hub.docker.com/v2/repositories/$1/tags/$2 > /dev/null 2>&1
}

# Parse a template files
# args: $1 -- template filename
parse_template()
{
	while IFS= read -r line
	do
		# expected format:
		# VAR=VALUE # DOCSTRING
		var=${line%=*}

		val=${line#*=}
		val=$(echo "${val%#*}" | sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//' )

		cmt=$(echo "$line" | cut -s -d '#' -f 2- | sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//')

		req=$(echo "$cmt" | grep -q "(REQUIRED)" && echo "1")

		echo "$var|||$val|||$cmt|||$req"
	done < <(grep -E '^[^#]\w+=.*$' $1)
}

# Print usage info
usage()
{
	echo "usage:   $0 --provider=<provider_id> [options]"
	echo

	echo "options:"
	echo
	
	for TEMPLATE in "${TEMPLATES[@]}"; do
		providerid="${TEMPLATE##*.}"
		providername=$(head -n 1 $TEMPLATE | sed 's/^# *//')

		echo "$providername (--provider=$providerid):"
		while IFS= read -r s
		do
			var="${s%%"|||"*}"; s=${s#*"|||"}
			val="${s%%"|||"*}"; s=${s#*"|||"}
			cmt="${s%%"|||"*}"; s=${s#*"|||"}
			req="${s%%"|||"*}"; s=${s#*"|||"}

			printf "    %-45s %s\n" "$(varname_to_option $var)=<$val>" "$cmt"

#			echo "var=[[$var]] val=[[$val]] cmt=[[$cmt]]"
		done < <(parse_template $TEMPLATE)
		echo
	done
}

# Collect all required options from a template file
add_required()
{
	while IFS= read -r s
	do
		var="${s%%"|||"*}"; s=${s#*"|||"}
		val="${s%%"|||"*}"; s=${s#*"|||"}
		cmt="${s%%"|||"*}"; s=${s#*"|||"}
		req="${s%%"|||"*}"; s=${s#*"|||"}

		if [[ $req == 1 ]]; then
			REQUIRED+=($var)
		fi

	done < <(parse_template $1)
}

check_prerequisites()
{
	echo "== Checking prerequisites:"
	echo

	# see if we have doctl
	hash doctl 2>/dev/null && msg check "  found doctl" || { errmsg "  error: no doctl on path. Install Digital Ocean CLI tools."; exit -1; }

	# see if we're authenticated
	doctl compute droplet list >/dev/null 2>&1 && msg check "  logged into DO" || { errmsg "  error: issues authenticating to Digital Ocean.."; exit -1; }

	# see if we have kubectl
	hash kubectl 2>/dev/null && msg check "  found kubectl" || { errmsg "  error: no kubectl on path. Install Kuberbetes CLI tools."; exit -1; }

	# see if we have helm
	hash helm 2>/dev/null && msg check "  found helm" || { errmsg "  error: no helm on path. Install Helm CLI tools."; exit -1; }

	# see if we have certbot
	hash certbot 2>/dev/null && msg check "  found certbot" || { errmsg "  error: no certbot on path. Install certbot tools."; exit -1; }

	# see if the domain has been properly set up
	DOMAIN=$(echo "$HUB_FQDN" | cut -d . -f 2-)
	doctl compute domain records list "$DOMAIN" >/dev/null 2>&1 && msg check "  DO is managing $DOMAIN" || { errmsg "  error: domain not found. Please delegate '$DOMAIN' to DO's DNS service."; exit -1; }

	echo
}

# cp_with_subst <source> <dest>
# fill out the template written in our templating mini-language.
# language rules:
#   -- "##vars FOO BAR" defines FOO BAR as variables to expand
#   -- "text txt ##if -n $GAGA" means the line will appear in output only if [[ -n $GAGA ]] evals to true
#   -- "$FOO $BAZ" will expand $FOO (as it was define in ##vars but not $BAZ
cp_with_subst()
{
	VARS=()
	while IFS= read -r line
	do
		# check if this is the ##vars line
		if [[ $line == \#\#vars* ]]; then
			VARS+=(${line#"##vars "})
			continue
		fi
	
		# expected format:
		# ...text.. ##if PREDICATE
		TEXT="${line%"##if"*}"
		PRED="${line#*"##if"}"
		[[ "$TEXT" == "$line" ]] && PRED=

		# conditional lines
		if [[ ! -z $PRED ]]; then
			if eval "[[ $PRED ]]"; then
				line="$TEXT"
			else
				continue
			fi
		fi

		# variable expansion
		for VAR in "${VARS[@]}"; do
			##echo "[[$line]] VAR=$VAR=${!VAR}" 1>&2
			line=${line//"\${$VAR}"/"${!VAR}"} #" ## <-- work around a syntax highlighting bug in joe
			line=${line//"\$$VAR"/"${!VAR}"}   #" ## <-- work around a syntax highlighting bug in joe
		done

		echo "$line"
	done < "$1" > "$2"
	##cat "$2"
}

############################

msg()
{
	[[ "$1" == "done" ]] && symbol="👍"
	[[ "$1" == "check" ]] && symbol="✅"
	[[ "$1" == "skip" ]] && symbol="⏩"

	echo "$symbol $2"
}

gen_proxy_secret()
{
	# don't regenerate if it already exists
	if [[ -f etc/secrets/proxy.yaml ]]; then
		msg skip "  skipping etc/secrets/proxy.yaml; already exists."
		return
	fi

	cat > etc/secrets/proxy.yaml <<-EOF
	proxy:
	  secretToken: "$(openssl rand -hex 32)"
	EOF
	
	msg done "  generated etc/secrets/proxy.yaml"
}

gen_github_auth()
{
	if [[ -z $GITHUB_OAUTH_CREDS ]]; then
		if [[ -f "etc/secrets/github-auth.yaml" ]]; then
			rm -f "etc/secrets/github-auth.yaml"
			echo "disabling GitHub authentication (rerun with --github-oauth-client-id and --github-oauth-secret to re-enable)"
		fi
		return
	fi

	# read the creds from the file
	exec 3<"$GITHUB_OAUTH_CREDS"
	IFS= read -r GITHUB_OAUTH_CLIENT_ID <&3
	IFS= read -r GITHUB_OAUTH_SECRET <&3

	# simple validation
	[[ ${#GITHUB_OAUTH_CLIENT_ID} != 20 ]] && { errmsg "error: GitHub OAuth App Client ID (==$GITHUB_OAUTH_CLIENT_ID) from file $GITHUB_OAUTH_CREDS must be 20 chars long."; exit -1; }

	GITHUB_OAUTH_CALLBACK="https://$HUB_FQDN/hub/oauth_callback"

	# FIXME: this silently deletes any double quotes in the template file
	cp_with_subst templates/helm/github-auth.yaml.sht etc/secrets/github-auth.yaml

	msg done "  generated etc/secrets/github-auth.yaml"
}

gen_ssl()
{
	if [[ -z $LETSENCRYPT_EMAIL ]]; then
		if [[ -f "etc/secrets/ssl.yaml" ]]; then
			rm -f "etc/secrets/ssl.yaml"
			echo "disabling SSL (rerun with --letsencrypt-email=owner-email@example.com to re-enable)"
		fi
		return
	fi

	# don't regenerate if it already exists
	if [[ -f etc/secrets/ssl.yaml ]]; then
		msg skip "  skipping etc/secrets/ssl.yaml; already exists."
		return
	fi

	# generate new certificates
	OUTPUT=$(certbot -d "$HUB_FQDN" \
		--keep --manual \
		--preferred-challenges dns certonly \
		--config-dir etc/secrets/certbot/config --work-dir etc/secrets/certbot/work --logs-dir etc/secrets/certbot/logs \
		-m "$LETSENCRYPT_EMAIL" \
		--agree-tos --no-eff-email --manual-public-ip-logging-ok \
		--manual-auth-hook=bin/certbot-auth.sh 2>&1)
	if [[ $? -ne 0 ]]; then
		errmsg "======="
		errmsg "$OUTPUT"
		errmsg "======="
		errmsg "error: something went wrong with SSL certificate generation; see above. aborting.."
		exit -1
	fi

	cat > etc/secrets/ssl.yaml <<-EOF
	proxy:
	  https:
	    hosts:
	      - $HUB_FQDN
	    type: manual
	    manual:
	      key: |
	$(cat etc/secrets/certbot/config/live/$HUB_FQDN/privkey.pem |  sed 's/^/        /')
	      cert: |
	$(cat etc/secrets/certbot/config/live/$HUB_FQDN/fullchain.pem |  sed 's/^/        /')
	EOF

	msg done "  generated etc/secrets/ssl.yaml"
}

doctl_size_list_json()
{
	# Cache so we don't keep hitting the API server
	if ! find node_list.cache.json -mmin +60 >/dev/null 2>&1; then
		# cache doesn't exist or expired
		doctl compute size list -o json > node_list.cache.json
	fi

	cat node_list.cache.json
}

gen_config() {
	# check if we're overwriting
	#if [[ -f "$CONFIG" && $FORCE != "1" ]]; then
	#	errmsg "error: $CONFIG already exists. refusing to proceed in an abundance of caution."
	#	exit -1
	#fi

	# generate the include file with configuration
	mkdir -p "$(dirname $CONFIG)"
	#eval "echo \"$(<$TEMPLATE)\"" > "$CONFIG"
	while IFS= read -r s
	do
		var="${s%%"|||"*}"; s=${s#*"|||"}
		val="${s%%"|||"*}"; s=${s#*"|||"}
		cmt="${s%%"|||"*}"; s=${s#*"|||"}
		req="${s%%"|||"*}"; s=${s#*"|||"}

		echo "# $cmt"
		# if this variable was overridden on the command line, replace the default value
		if [[ ! -z "${!var}" ]]; then
			val="${!var}"
		else
			# otherwise, make the default value available to subsequent generators
			eval "$var='$val'"
		fi
		echo "$var=$val"
		echo "export $var"
		echo
	done < <(parse_template $TEMPLATE) > "$CONFIG"

	# validation
	NODEPROPS=( $(doctl_size_list_json | jq -r '.[] | select(.slug == "'"$SIZE"'") | [.vcpus, .memory, .price_hourly] | @tsv ') )
	NODE_CPU=${NODEPROPS[0]}
	NODE_MEMORY=${NODEPROPS[1]}
	NODE_PRICE=${NODEPROPS[2]}

	# CPU and memory overheads
	# Estimated by inspecting "kubectl describe node s-4vcpu-8gb-a6hd"
	OH_MEM=1.5
	OH_CPU=1

	# how many users can use this node? keep ~0.5CPU for overhead
	node_users_cpu=$(echo "scale=0; ($NODE_CPU-$OH_CPU)/$USER_CPU" | bc)
	[[ node_users_cpu -gt 0 ]] || { errmsg "error: number of vcpus in a node is too small to accommodat even a single user. change --size or --user-cpu."; exit -1; }

	# how many users can use this node? keep ~0.5GiB for overhead
	node_users_ram=$(echo "scale=0; ($NODE_MEMORY/1024-$OH_MEM)/$USER_MEMORY" | bc)
	[[ node_users_ram -gt 0 ]] || { errmsg "error: node memory is too small to accommodat even a single user. change --size or --user-memory."; exit -1; }

	# total users
	node_users=$(( $node_users_cpu < $node_users_ram ? $node_users_cpu : $node_users_ram ))
	users=$((node_users*$NODES))

	# cost per hour
	cost_per_day=$(printf %.2f $(echo "$NODE_PRICE*$NODES*24" | bc))
	storage_cost_per_user_per_day=$(printf %.2f $(echo "0.0015*$USER_DISK*24" | bc))

	# progress report
	msg done "  generated $CONFIG"
}

gen_images()
{
	if [[ -n $HUB_IMAGE ]]; then
		HUB_IMAGE_NAME=${HUB_IMAGE%%":"*}
		HUB_IMAGE_TAG=${HUB_IMAGE##*":"}
		
		docker_tag_exists $HUB_IMAGE_NAME $HUB_IMAGE_TAG || { errmsg "error: image $HUB_IMAGE doesn't exist in the Docker repository."; exit -1; }
		msg check "  verified that $HUB_IMAGE is in the Docker repo."
	fi

	if [[ -n $JUPYTER_IMAGE ]]; then
		JUPYTER_IMAGE_NAME=${JUPYTER_IMAGE%%":"*}
		JUPYTER_IMAGE_TAG=${JUPYTER_IMAGE##*":"}

		docker_tag_exists $JUPYTER_IMAGE_NAME $JUPYTER_IMAGE_TAG || { errmsg "error: image $JUPYTER_IMAGE doesn't exist in the Docker repository."; exit -1; }
		msg check "  verified that $JUPYTER_IMAGE is in the Docker repo."
	fi

	if [[ -f etc/images ]]; then
		msg skip "  skipping creation of etc/images; already exists."
	else
		cp -r images etc/
		msg done "  generated etc/images"
	fi
}

gen_values_yaml() {
	# copy default values.yaml
	cp_with_subst templates/helm/values.yaml.sht etc/values.yaml
	msg done "  generated etc/values.yaml"
}

show_summary() {
	echo
	echo "========================================================================="
	echo ""
	echo "  JupyterHub Deployment Configuration Summary:"
	echo ""
	echo "  Cluster:"
	echo "    ${NODES} nodes, ${NODE_CPU}vcpus and ${NODE_MEMORY}mib each ($SIZE instance type)."
	echo "      note: ${OH_CPU}vcpus and ${OH_MEM}GiB of each node are reserved by the system."
	echo "    Enough for ~$users simultaneous users (at ${USER_CPU}vcpus and ${USER_MEMORY}gib per user)"
	echo "    Expected cost: "
	echo "      Compute cluster: \$$cost_per_day/day"
	echo "      User storage: \$$storage_cost_per_user_per_day/user/day"
	echo ""
	echo "  Environment:"
	echo "    Each user is guaranteed ${USER_CPU}vcpus, ${USER_MEMORY}gib RAM, and ${USER_DISK}GiB of disk space"
	echo "    Hub address will be https://$HUB_FQDN"
	echo "      Let's Encrypt SSL cert will be registered to $LETSENCRYPT_EMAIL"
if [[ -n $GITHUB_OAUTH_CREDS ]]; then
	echo "    Authenticating via GitHub"
if [[ -n $GITHUB_ORG ]]; then
	echo "      Only users belonging to $GITHUB_ORG can log in."
else
	echo "      Any GitHub user can log in."
fi
fi
if [[ -n $HUB_IMAGE || -n $JUPYTER_IMAGE ]]; then
	echo "    Images:"
fi
if [[ -n $HUB_IMAGE ]]; then
	echo "      Hub: $HUB_IMAGE"
fi
if [[ -n $JUPYTER_IMAGE ]]; then
	echo "      Jupyter: $JUPYTER_IMAGE"
fi
	echo ""
	echo "========================================================================="
	echo
}

#############################################################################3
# Main
#############################################################################3

# Parse the command line
POSITIONAL=()
while [[ $# -gt 0 ]]
do
	key="$1"
	case "$key" in
		-h|--help)
			usage
			exit -1
		;;
		
		-f|--force)
			FORCE=1
			shift;
		;;

		# Simple options with an argument
		--*=*)
			eval "$(option_to_varname $key)='${key#*=}'"
			shift;
		;;

		--*)
			eval "$(option_to_varname $key)=$2"
			shift;
			shift;
		;;

		*)
		POSITIONAL+=("$1")
		shift;
		;;
	esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters

# Discover provider
if [[ -z "$PROVIDER" ]]; then
	errmsg "error: --provider must be specified"
	exit -1
fi
TEMPLATE="templates/config/config.sh.$PROVIDER"
if [[ ! -f $TEMPLATE ]]; then
	errmsg "error: provider '$PROVIDER' unknown."
	exit -1
fi

# Discover all required options for this provider
REQUIRED=(PROVIDER)
add_required $TEMPLATE

# Verify we have all required options
for key in ${REQUIRED[@]}; do
	if [[ -z ${!key} ]]; then
		opt="${key//_/-}"
		opt=$(echo "$opt" | awk '{print tolower($0)}')
		errmsg "error: --$opt=<$key> must be specified for provider '$PROVIDER'."
		err=1
	fi
done
test "$err" == "1" && { errmsg; errmsg "run $0 -h for help"; exit -1; }

# Check prerequisites
check_prerequisites

# generate output files
echo "== Generating configuration:"
echo
mkdir -p etc/secrets
gen_config
gen_proxy_secret
gen_ssl
gen_github_auth

gen_images
gen_values_yaml

show_summary

echo "========================================================================="
echo "   Configuration success. run 'make all' to (re)deploy your cluster."
echo "========================================================================="
